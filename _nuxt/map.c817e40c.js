var e=Object.defineProperty,t=(t,n,i)=>(((t,n,i)=>{n in t?e(t,n,{enumerable:!0,configurable:!0,writable:!0,value:i}):t[n]=i})(t,"symbol"!=typeof n?n+"":n,i),i);import{C as n}from"./index.6c8f1534.js";import{T as i}from"./three-object.387dbe05.js";import{P as s,d as r,e as o,W as a,F as c,S as v,D as d,f,U as x,C as l,N as p,V as m,B as h,g as u}from"./three.module.522d90d0.js";import{S as _,g as y,a as g,b as M}from"./rotate.34bd89a7.js";import{s as A}from"./simple-three.8301cfdd.js";import{R as w}from"./index.82028ee2.js";import{g as C}from"./drawing.d211013c.js";import{W as I,g as F,p as S}from"./tweakpane.cfae8375.js";import{g as z}from"./circle.29cefe4c.js";import{a as L}from"./index-default.25f36e61.js";class T{constructor(){t(this,"checkProgram",(e=>{if(!e||!this.renderer)return;const t=this.renderer.info.programs.find((t=>t.name==e.type));t&&t.program&&(this.shader=e,this.defines=e.defines,t.vertexShader.__SPECTOR_Object_TAG.displayText="Vertex — ",t.fragmentShader.__SPECTOR_Object_TAG.displayText="Fragment — ",t.program.__SPECTOR_rebuildProgram=this.rebuildShader,clearInterval(this.checkProgramInterval))})),t(this,"rebuildShader",((e,t,n)=>{const i=this.shader;i.isRawShaderMaterial=!0,i.defines=void 0,i.vertexShader=e.replace(/! /g,"!"),i.fragmentShader=t.replace(/! /g,"!"),i.needsUpdate=!0;n(this.renderer.info.programs.find((e=>e.name==i.type)).program),this.checkProgramInterval=setInterval(this.checkProgram,20,i)}))}add(e,{pane:t,type:n="ShaderMaterial",renderer:i}={}){if(!t||!window.spector)return;const s={capture:()=>this.capture(e)},r="ShaderMaterial"!=n?n:"ShaderMaterial"!=e.type?e.type:"ShaderMaterial";t.addButton({title:`— ${r}`}).on("click",s.capture),e.type=r,this.renderer=i}capture(e){const t=document.querySelector('canvas[__spector_context_type="webgl"]')||document.querySelector('canvas[__spector_context_type="webgl2"]');window.spector.captureNextFrame(t,{quickCapture:!0}),this.checkProgram(e)}}let N;const b=()=>(N||(N=new T),N);class P{constructor(e,{data:t=new Float32Array(16),type:n=c,geometry:i,renderOptions:v={target:null}}){const d=t;this.renderer=e,this.passes=[],this.dataLength=d.length/4,this.renderOptions=v,this.size=Math.pow(2,Math.ceil(Math.log(Math.ceil(Math.sqrt(this.dataLength)))/Math.LN2)),this.geometry=i||new s(this.size,this.size),this.scene=new r,this.orthoCamera=new o(this.size/-2,this.size/2,this.size/2,this.size/-2,1e-5,1e3),this.coords=new Float32Array(2*this.dataLength);for(let s=0;s<this.dataLength;s++){const e=s%this.size/this.size,t=Math.floor(s/this.size)/this.size;this.coords.set([e,t],2*s)}this.uniform={value:B(d,this.size)};const x={type:n,format:f,minFilter:p,magFilter:p,depthBuffer:!1,generateMipmaps:!1,unpackAlignment:1};this.fbo={read:new a(this.size,this.size,x),write:new a(this.size,this.size,x),swap:()=>{[this.fbo.read,this.fbo.write]=[this.fbo.write,this.fbo.read],this.uniform.value=this.fbo.read.texture}}}addPass({vertexShader:e=R,fragmentShader:t=U,uniforms:n={},textureUniform:i="tMap",enabled:s=!0}={}){n[i]=this.uniform;const r=new v({vertexShader:e,fragmentShader:t,uniforms:n}),o=new _(this.renderer,{shader:r,width:this.size,height:this.size,renderOptions:{textureUniform:i}});return o.enabled=s,this.passes.push(o),o}render(){this.passes.filter((e=>e.enabled)).forEach((e=>{this.renderer.setRenderTarget(this.fbo.write),this.renderer.render(e.scene,e.orthoCamera),this.renderer.setRenderTarget(this.renderOptions.target),this.fbo.swap()}))}}const B=(e,t)=>{const n=(()=>{if(e.length===t*t*4)return e;{const n=new Float32Array(t*t*4);return n.set(e),n}})(),i=new d(n,t,t,f,c,x,l,l,p,p);return i.flipY=!1,i.generateMipmaps=!1,i.needsUpdate=!0,i},R="\n    varying vec2 vUv;\n    void main() {\n        vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n        gl_Position = projectionMatrix * mvPosition;\n        vUv = uv;\n    }\n",U="\n    varying vec2 vUv;\n    uniform sampler2D tMap;\n    void main() {\n        vec4 tDiffuse = texture2D(tMap, vUv);\n        gl_FragColor = tDiffuse;\n    }\n",O="#define GLSLIFY 1\n#ifndef FNC_MOD289\n#define FNC_MOD289\nfloat mod289_0(in float x){return x-floor(x*(1./289.))*289.;}vec2 mod289_0(in vec2 x){return x-floor(x*(1./289.))*289.;}vec3 mod289_0(in vec3 x){return x-floor(x*(1./289.))*289.;}vec4 mod289_0(in vec4 x){return x-floor(x*(1./289.))*289.;}\n#endif\n#ifndef FNC_MOD289\n#define FNC_MOD289\nfloat mod289_1(in float x){return x-floor(x*(1./289.))*289.;}vec2 mod289_1(in vec2 x){return x-floor(x*(1./289.))*289.;}vec3 mod289_1(in vec3 x){return x-floor(x*(1./289.))*289.;}vec4 mod289_1(in vec4 x){return x-floor(x*(1./289.))*289.;}\n#endif\n#ifndef FNC_PERMUTE\n#define FNC_PERMUTE\nfloat permute(in float x){return mod289_1(((x*34.)+1.)*x);}vec3 permute(in vec3 x){return mod289_1(((x*34.0)+1.0)*x);}vec4 permute(in vec4 x){return mod289_1(((x*34.)+1.)*x);}\n#endif\n#ifndef FNC_TAYLORINVSQRT\n#define FNC_TAYLORINVSQRT\nfloat taylorInvSqrt(in float r){return 1.79284291400159-0.85373472095314*r;}vec4 taylorInvSqrt(in vec4 r){return 1.79284291400159-0.85373472095314*r;}\n#endif\n#ifndef FNC_GRAD4\n#define FNC_GRAD4\nvec4 grad4(float j,vec4 ip){const vec4 ones=vec4(1.0,1.0,1.0,-1.0);vec4 p,s;p.xyz=floor(fract(vec3(j)*ip.xyz)*7.0)*ip.z-1.0;p.w=1.5-dot(abs(p.xyz),ones.xyz);s=vec4(lessThan(p,vec4(0.0)));p.xyz=p.xyz+(s.xyz*2.0-1.0)*s.www;return p;}\n#endif\n#ifndef FNC_SNOISE\n#define FNC_SNOISE\nfloat snoise(in vec2 v){const vec4 C=vec4(0.211324865405187,0.366025403784439,-0.577350269189626,0.024390243902439);vec2 i=floor(v+dot(v,C.yy));vec2 x0=v-i+dot(i,C.xx);vec2 i1;i1=(x0.x>x0.y)? vec2(1.0,0.0): vec2(0.0,1.0);vec4 x12=x0.xyxy+C.xxzz;x12.xy-=i1;i=mod289_0(i);vec3 p=permute(permute(i.y+vec3(0.0,i1.y,1.0))+i.x+vec3(0.0,i1.x,1.0));vec3 m=max(0.5-vec3(dot(x0,x0),dot(x12.xy,x12.xy),dot(x12.zw,x12.zw)),0.0);m=m*m;m=m*m;vec3 x=2.0*fract(p*C.www)-1.0;vec3 h=abs(x)-0.5;vec3 ox=floor(x+0.5);vec3 a0=x-ox;m*=1.79284291400159-0.85373472095314*(a0*a0+h*h);vec3 g;g.x=a0.x*x0.x+h.x*x0.y;g.yz=a0.yz*x12.xz+h.yz*x12.yw;return 130.0*dot(m,g);}float snoise(in vec3 v){const vec2 C=vec2(1.0/6.0,1.0/3.0);const vec4 D=vec4(0.0,0.5,1.0,2.0);vec3 i=floor(v+dot(v,C.yyy));vec3 x0=v-i+dot(i,C.xxx);vec3 g_0=step(x0.yzx,x0.xyz);vec3 l=1.0-g_0;vec3 i1=min(g_0.xyz,l.zxy);vec3 i2=max(g_0.xyz,l.zxy);vec3 x1=x0-i1+C.xxx;vec3 x2=x0-i2+C.yyy;vec3 x3=x0-D.yyy;i=mod289_0(i);vec4 p=permute(permute(permute(i.z+vec4(0.0,i1.z,i2.z,1.0))+i.y+vec4(0.0,i1.y,i2.y,1.0))+i.x+vec4(0.0,i1.x,i2.x,1.0));float n_=0.142857142857;vec3 ns=n_*D.wyz-D.xzx;vec4 j=p-49.0*floor(p*ns.z*ns.z);vec4 x_=floor(j*ns.z);vec4 y_=floor(j-7.0*x_);vec4 x=x_*ns.x+ns.yyyy;vec4 y=y_*ns.x+ns.yyyy;vec4 h=1.0-abs(x)-abs(y);vec4 b0=vec4(x.xy,y.xy);vec4 b1=vec4(x.zw,y.zw);vec4 s0=floor(b0)*2.0+1.0;vec4 s1=floor(b1)*2.0+1.0;vec4 sh=-step(h,vec4(0.0));vec4 a0=b0.xzyw+s0.xzyw*sh.xxyy;vec4 a1=b1.xzyw+s1.xzyw*sh.zzww;vec3 p0=vec3(a0.xy,h.x);vec3 p1=vec3(a0.zw,h.y);vec3 p2=vec3(a1.xy,h.z);vec3 p3=vec3(a1.zw,h.w);vec4 norm=taylorInvSqrt(vec4(dot(p0,p0),dot(p1,p1),dot(p2,p2),dot(p3,p3)));p0*=norm.x;p1*=norm.y;p2*=norm.z;p3*=norm.w;vec4 m=max(0.6-vec4(dot(x0,x0),dot(x1,x1),dot(x2,x2),dot(x3,x3)),0.0);m=m*m;return 42.0*dot(m*m,vec4(dot(p0,x0),dot(p1,x1),dot(p2,x2),dot(p3,x3)));}float snoise(in vec4 v){const vec4 C=vec4(0.138196601125011,0.276393202250021,0.414589803375032,-0.447213595499958);vec4 i=floor(v+dot(v,vec4(.309016994374947451)));vec4 x0=v-i+dot(i,C.xxxx);vec4 i0;vec3 isX=step(x0.yzw,x0.xxx);vec3 isYZ=step(x0.zww,x0.yyz);i0.x=isX.x+isX.y+isX.z;i0.yzw=1.0-isX;i0.y+=isYZ.x+isYZ.y;i0.zw+=1.0-isYZ.xy;i0.z+=isYZ.z;i0.w+=1.0-isYZ.z;vec4 i3=clamp(i0,0.0,1.0);vec4 i2=clamp(i0-1.0,0.0,1.0);vec4 i1=clamp(i0-2.0,0.0,1.0);vec4 x1=x0-i1+C.xxxx;vec4 x2=x0-i2+C.yyyy;vec4 x3=x0-i3+C.zzzz;vec4 x4=x0+C.wwww;i=mod289_0(i);float j0=permute(permute(permute(permute(i.w)+i.z)+i.y)+i.x);vec4 j1=permute(permute(permute(permute(i.w+vec4(i1.w,i2.w,i3.w,1.0))+i.z+vec4(i1.z,i2.z,i3.z,1.0))+i.y+vec4(i1.y,i2.y,i3.y,1.0))+i.x+vec4(i1.x,i2.x,i3.x,1.0));vec4 ip=vec4(1.0/294.0,1.0/49.0,1.0/7.0,0.0);vec4 p0=grad4(j0,ip);vec4 p1=grad4(j1.x,ip);vec4 p2=grad4(j1.y,ip);vec4 p3=grad4(j1.z,ip);vec4 p4=grad4(j1.w,ip);vec4 norm=taylorInvSqrt(vec4(dot(p0,p0),dot(p1,p1),dot(p2,p2),dot(p3,p3)));p0*=norm.x;p1*=norm.y;p2*=norm.z;p3*=norm.w;p4*=taylorInvSqrt(dot(p4,p4));vec3 m0=max(0.6-vec3(dot(x0,x0),dot(x1,x1),dot(x2,x2)),0.0);vec2 m1=max(0.6-vec2(dot(x3,x3),dot(x4,x4)),0.0);m0=m0*m0;m1=m1*m1;return 49.0*(dot(m0*m0,vec3(dot(p0,x0),dot(p1,x1),dot(p2,x2)))+dot(m1*m1,vec2(dot(p3,x3),dot(p4,x4))));}vec3 snoise3(vec3 x){float s=snoise(vec3(x));float s1=snoise(vec3(x.y-19.1,x.z+33.4,x.x+47.2));float s2=snoise(vec3(x.z+74.2,x.x-124.5,x.y+99.4));vec3 c=vec3(s,s1,s2);return c;}vec3 snoise3(vec4 x){float s=snoise(vec4(x));float s1=snoise(vec4(x.y-19.1,x.z+33.4,x.x+47.2,x.w));float s2=snoise(vec4(x.z+74.2,x.x-124.5,x.y+99.4,x.w));vec3 c=vec3(s,s1,s2);return c;}\n#endif\n#ifndef FBM_OCTAVES\n#define FBM_OCTAVES 4\n#endif\n#ifndef FBM_NOISE_FNC\n#define FBM_NOISE_FNC(POS_UV) snoise(POS_UV)\n#endif\n#ifndef FBM_VALUE_INITIAL\n#define FBM_VALUE_INITIAL 0.0\n#endif\n#ifndef FBM_SCALE_SCALAR\n#define FBM_SCALE_SCALAR 2.0\n#endif\n#ifndef FBM_AMPLITUD_INITIAL\n#define FBM_AMPLITUD_INITIAL 0.5\n#endif\n#ifndef FBM_AMPLITUD_SCALAR\n#define FBM_AMPLITUD_SCALAR 0.5\n#endif\n#ifndef FNC_FBM\n#define FNC_FBM\nfloat fbm(in vec2 st){float value=FBM_VALUE_INITIAL;float amplitud=FBM_AMPLITUD_INITIAL;for(int i=0;i<FBM_OCTAVES;i++){value+=amplitud*FBM_NOISE_FNC(st);st*=FBM_SCALE_SCALAR;amplitud*=FBM_AMPLITUD_SCALAR;}return value;}float fbm(in vec3 pos){float value=FBM_VALUE_INITIAL;float amplitud=FBM_AMPLITUD_INITIAL;for(int i=0;i<FBM_OCTAVES;i++){value+=amplitud*FBM_NOISE_FNC(pos);pos*=FBM_SCALE_SCALAR;amplitud*=FBM_AMPLITUD_SCALAR;}return value;}\n#endif\n",D="#define GLSLIFY 1\nfloat sLine(in vec2 a,in vec2 b){vec2 p=b-a;float d=abs(dot(normalize(vec2(p.y,-p.x)),a));return d*2.0;}float line(in vec2 a,in vec2 b){float d=sLine(a,b);return fill(d);}float line(in vec2 a,in vec2 b,in float t){float d=sLine(a,b);return stroke(d,t);}float line(in vec2 p,in float a,in float t){vec2 b=p+vec2(sin(a),cos(a));return line(p,b,t);}";class E extends n{constructor(){super(...arguments),t(this,"options",{vOffset:new m,vResolution:null,size:128}),t(this,"props",{rX:.5*-Math.PI,s:15,offsetNoise:{x:-2.78,y:-1},FBM_OCTAVES:4,FBM_VALUE_INITIAL:.21,FBM_SCALE_SCALAR:1.86,FBM_AMPLITUD_INITIAL:.34,FBM_AMPLITUD_SCALAR:1.2,defines:e=>({FBM_OCTAVES:e.FBM_OCTAVES,FBM_VALUE_INITIAL:e.FBM_VALUE_INITIAL,FBM_SCALE_SCALAR:e.FBM_SCALE_SCALAR,FBM_AMPLITUD_INITIAL:e.FBM_AMPLITUD_INITIAL,FBM_AMPLITUD_SCALAR:e.FBM_AMPLITUD_SCALAR}),uniforms:e=>({offsetNoise:{...e.offsetNoise}})})}async onSetup(){this.geoSimple=new s(2,2),this.vOffsetNoise=new m,await this.createGPGPUHeight(),await this.createQuad(),await this.createDots()}async createGPGPUHeight(){const{size:e}=this.options,t=w.getRenderer(),n=this.pHeight=new P(t,{data:new Float32Array(e*e*4)});this.pHeightPass=n.addPass({fragmentShader:`\n                varying vec2 vUv;\n                uniform sampler2D tMap;\n                uniform vec2 uOffsetNoise;\n                float mod289_1(in float x){return x-floor(x*(1./289.))*289.;}\n                vec2 mod289_1(in vec2 x){return x-floor(x*(1./289.))*289.;}\n                vec3 mod289_1(in vec3 x){return x-floor(x*(1./289.))*289.;}\n                vec4 mod289_1(in vec4 x){return x-floor(x*(1./289.))*289.;}\n                ${O}\n                void main() {\n                    vec2 st = vUv;\n                         st += uOffsetNoise;\n                    float n = fbm(st);\n                    vec4 position = vec4(0.);\n                         position.y = n;\n                    gl_FragColor = position;\n                }\n            `,uniforms:{uOffsetNoise:{value:this.vOffsetNoise}}})}async createQuad(){const{vResolution:e,size:t}=this.options,n=this.shaderMap=new v({vertexShader:`\n                attribute vec2 coords;\n                varying vec2 vUv;\n                varying vec2 vCoords;\n                varying float vHeight;\n                uniform sampler2D tMapHeight;\n                ${F}\n                void main() {\n                    vUv = uv;\n                    vec2 st = uv;\n                    float limit = 0.;\n                    \n                    float h = texture2D(tMapHeight, coords).y;\n                    float hh = step(limit, h);\n                    \n                    vec3 transformed = vec3( position );\n                    transformed.y -= (h * 0.14) * hh;\n                    \n                    vec4 mvPosition = modelViewMatrix * vec4( transformed, 1.0 );\n                    gl_Position = projectionMatrix * mvPosition;\n                    vHeight = h;\n                    vCoords = coords;\n                }`,fragmentShader:`\n                varying vec2 vUv;\n                varying float vHeight;\n                varying vec2 vCoords;\n                uniform vec2 uResolution;\n                uniform vec2 uOffsetNoise;\n                uniform float uProgress;\n                // uniform sampler2D tMapHeight;\n                // uniform sampler2D tMapHeightPx;\n                // uniform sampler2D tMapHeightPxTexture;\n                float mod289_1(in float x){return x-floor(x*(1./289.))*289.;}\n                vec2 mod289_1(in vec2 x){return x-floor(x*(1./289.))*289.;}\n                vec3 mod289_1(in vec3 x){return x-floor(x*(1./289.))*289.;}\n                vec4 mod289_1(in vec4 x){return x-floor(x*(1./289.))*289.;}\n                ${O}\n                #define GLSLIFY 1\n#ifndef FNC_RECTSDF\n#define FNC_RECTSDF\nfloat sdRect(vec2 p,vec2 b,float r){vec2 d=abs(p-0.5)*4.2-b+vec2(r);return min(max(d.x,d.y),0.0)+length(max(d,0.0))-r;}float sdRect(vec2 p,float b,float r){return sdRect(p,vec2(b),r);}float sdRect(in vec2 st,in vec2 s){st=st*2.-1.;return max(abs(st.x/s.x),abs(st.y/s.y));}float sdRect(in vec2 st,in float s){return sdRect(st,vec2(s));}float sdRect(in vec2 st){return sdRect(st,vec2(1.0));}\n#endif\n\n                ${y}\n                ${g}\n                ${C}\n                ${D}\n                #define GLSLIFY 1\nvec2 tile(in vec2 p,vec2 w){return fract(mod(p+w/2.0,w))-(w/2.0);}vec2 tile(in vec2 p,float w){return tile(p,vec2(w));}float grid(in vec2 p,in float w,in float t){vec2 l=tile(p,w);float d=0.0;d+=line(l,l+vec2(0.0,0.1),t);d+=line(l,l+vec2(0.1,0.0),t);return d;}\n                void main() {\n                    vec2 st = vUv;\n    \n                    // edges\n                    float edges = fill(sdRect(st), 0.8, 0.2);\n                    float limit = -0.04;\n                    \n                    // height\n                    vec2 stNoise = vCoords + uOffsetNoise; \n                    float h = fbm(stNoise);\n                    float rnd = smoothstep(0.5, 1., fract(h * 4.));\n                    float n = fract((0.06 + h) * 22.);\n                    float sdMap = stroke(n, 0.4, size(40.) + (rnd * size(100.)));\n                          sdMap *= step(limit, h);\n                    vec3 cMap = vec3((0.46 * n) + (0.2 * rnd));\n                    \n                    // grid\n                    vec2 stGrid = st;\n                    float w = mix(0.4, 0.1, uProgress);\n                    float sGrid = 10.;\n                    float sdGrid = grid(stGrid, size(sGrid), size(0.4));\n                    sdGrid *= 1. - step(limit, h);\n                    sdGrid *= 0.12;\n                    vec3 cGrid = vec3(1.);\n                    float s = edges;\n                    float sd = sdMap + sdGrid;\n                    vec3 c = mix(cGrid, cMap, step(limit, h));\n                    \n                    if(s <= 0.5) discard;\n                    gl_FragColor = vec4(c * sd * s, 1.);\n                    // gl_FragColor = vec4(vec3(st.xy, 1.), 1.);\n                    // gl_FragColor = vec4(vec3(1., 0., 0.), 1.);\n                    // gl_FragColor = vec4(vec3(nRnd), 1.);\n                }`,uniforms:{tMapHeight:this.pHeight.uniform,uResolution:{value:e},uProgress:{value:0},uOffsetNoise:{value:this.vOffsetNoise}},defines:this.pHeightPass.shader.defines});b().add(n,{pane:await S,type:"AtlasMaterial",renderer:w.getRenderer()});const i=this.geo=new s(2,2,t-1,t-1);i.rotateX(.5*Math.PI),i.setAttribute("coords",new h(this.pHeight.coords,2));const r=this.quad=new u(i,n);r.name="MeshMap",this.object.add(r)}setDefines({FBM_OCTAVES:e,FBM_VALUE_INITIAL:t,FBM_SCALE_SCALAR:n,FBM_AMPLITUD_INITIAL:i,FBM_AMPLITUD_SCALAR:s}){var r;const o={FBM_OCTAVES:e,FBM_VALUE_INITIAL:t,FBM_SCALE_SCALAR:n,FBM_AMPLITUD_INITIAL:i,FBM_AMPLITUD_SCALAR:s};this.pHeightPass.shader.defines=o,this.pHeightPass.shader.needsUpdate=!0,this.shaderMap.defines=o,this.shaderMap.needsUpdate=!0,null==(r=this.pHeight)||r.render()}setUniforms({offsetNoise:e}){var t;this.vOffsetNoise.copy(e),null==(t=this.pHeight)||t.render()}async createDots(){const{vResolution:e,vOffset:t}=this.options,n=this.shaderDots=new v({vertexShader:A,fragmentShader:`\n                #include <common>\n                varying vec2 vUv;\n                uniform vec2 uResolution;\n                uniform vec2 uOffset;\n                uniform float uProgress;\n                ${C}\n                ${y}\n                ${g}\n                ${M}\n                ${z}\n                ${D}\n                void main() {\n                    vec2 st = vUv + uOffset;\n                         st *= 18.;\n                         st = rotate(st, PI * 0.3);\n                         st = fract(st);\n                    float sd = circle(st, size(10.));\n                    vec3 c = vec3(0.8);\n                    gl_FragColor = vec4(c, sd);\n                }`,uniforms:{uResolution:{value:e},uOffset:{value:t},uProgress:{value:0}},transparent:!0}),i=this.meshDots=new u(this.geoSimple,n);i.name="MeshDots",i.rotateX(1.6),i.position.y=-.04,this.object.add(i)}}L(E,[i,I(S,{expanded:!0,withoutKeys:"",keysOptions:{FBM_OCTAVES:{step:1},FBM_SCALE_SCALAR:{step:.01},offsetNoise:{x:{step:.01},y:{step:.01}}}})]);const j=Object.freeze(Object.defineProperty({__proto__:null,default:E},Symbol.toStringTag,{value:"Module"}));export{E as M,b as S,j as m};
