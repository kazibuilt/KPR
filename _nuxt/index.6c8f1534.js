const e=new Set,t=[];let n,o=0,r=!1,s=0;const i=()=>t[o-1],c=t=>{if(t&&t.isDependency){const n=t.getWatchers();n&&(n.forEach((t=>{e.has(t.notify)&&e.delete(t.notify),e.add(t.notify),c(t)})),p())}},a=t=>{e.add(t),p()},d=t=>{e.delete(t)},p=async()=>{r||(r=!0,s+=1,await(void 0===n&&(n=new Promise((e=>{e()})),n.then((()=>{n=void 0}))),n),h(),r=!1)},h=()=>{var t;(t=e).forEach((e=>{t.delete(e),e()})),t.clear()},f=new WeakMap,l=new WeakSet,u=(e,t,n,o,r,s=r,i,c)=>{let a=e.get(n);if(!a){if("function"==typeof o&&c)return;const d=t[n],p="function"==typeof d||"function"==typeof o?"computedProperty":"reactiveProperty";a=C({target:t,key:n,proxy:r,context:s,type:p,fn:"computedProperty"===p?d||o:void 0,deep:i}),e.set(n,a)}return a},y=(e,t)=>{if(e.has(t)){e.get(t).dispose(),e.delete(t)}},v=(e,{deep:t=!0,context:n}={})=>{if("object"!=typeof e||null===e)return e;if(f.has(e))return e;const o=Array.isArray(e),r=new Map,s=new Proxy(e,{get(e,c){const a=u(r,e,c,e[c],s,n,t,o),d=i();return a&&d&&(a.addWatcher(d),d.addDependency(a)),a&&a.isComputedProperty&&a.dirty&&a.invoke(),e[c]},set(e,a,d){const p=e[a];if((!o||"length"!==a)&&d===p)return!0;if(i())throw new Error("Not allowed to set a reactive property while it's watched");const h=u(r,e,a,d,s,n,t,o);return h.isComputedProperty||(h.set(d),c(h)),!0},deleteProperty:(e,t)=>(y(r,t),delete e[t],!0)});return f.set(s,r),n||l.add(s),t&&(n||(n=s),Object.keys(e).forEach((o=>{const r=e[o];"object"==typeof r&&null!==r&&(e[o]=v(r,{deep:t,context:n}))}))),s},w=e=>!!l.has(e)&&(g(e),l.delete(e),!0),g=e=>{for(const[,t]of Object.entries(e))"object"==typeof t&&null!==t&&g(t);if(f.has(e)){const t=f.get(e);t.forEach(((e,n)=>{y(t,n)}))}},b=(e,t)=>{if(!f.has(e))return!1;e[t];const n=f.get(e);return!!n.has(t)&&n.get(t).isComputedProperty},m=new WeakSet,C=({target:e,key:n,proxy:r,context:i,type:c,fn:a,deep:h})=>{const f="computedProperty"===c,l="observeFunction"===c,u="reactiveProperty"===c,y={type:c,dispose(){d(y.notify),y.dependencies&&y.dependencies.forEach((e=>{e.removeWatcher(y)}))},isComputedProperty:f,isObserveFunction:l,isReactiveProperty:u,isDependency:u||f,dependencies:void 0,freshDependencies:void 0,watchers:void 0};if(f&&(y.dirty=!0),(f||l)&&(y.invoke=()=>{var s;if(s=y,o=t.push(s),f){y.dirty=!1;const t=a(r,{context:i});t!==e[n]&&(e[n]=h?v(t,{deep:h,context:i}):t)}else a();let c;t.pop(),o=t.length,y.dependencies&&(y.dependencies.forEach((e=>{y.freshDependencies&&!y.freshDependencies.has(e)&&e.removeWatcher(y)})),y.dependencies.clear(),c=y.dependencies),y.dependencies=y.freshDependencies,y.freshDependencies=c},y.notify=()=>{f?y.watchedCount?y.invoke():y.dirty=!0:y.invoke()},y.addDependency=e=>{y.freshDependencies||(y.freshDependencies=new Set),y.freshDependencies.add(e)}),(u||f)&&(y.target=e,y.key=n,y.watchedCount=0,y.addWatcher=e=>{y.watchers||(y.watchers=new Set),y.watchers.has(e)||(y.watchers.add(e),(e.isObserveFunction||e.watchedCount)&&y.incrementWatchedCount())},y.removeWatcher=e=>{y.watchers.has(e)&&(y.watchers.delete(e),(e.isObserveFunction||e.watchedCount)&&y.decrementWatchedCount())},y.incrementWatchedCount=()=>{y.watchedCount+=1,1===y.watchedCount&&y.dependencies&&y.dependencies.forEach((e=>{e.incrementWatchedCount()}))},y.decrementWatchedCount=()=>{y.watchedCount-=1,0===y.watchedCount&&y.dependencies&&y.dependencies.forEach((e=>{e.decrementWatchedCount()}))},y.getWatchers=()=>y.watchers),u){let t,o;y.set=r=>{p();const c=s;if(c===t){if(o+=1,1e3===o)throw new Error(`Potential infinite loop occured for key '${n}'`)}else t=c,o=1;e[n]=h?v(r,{deep:h,context:i}):r}}return m.add(y),y},x=e=>{const t=C({type:"observeFunction",fn:e});return a(t.notify),()=>{t.dispose()}};let k=null;const _=()=>(k||(k=(()=>{const e=[];let t=null;const n=o=>{e.forEach((e=>e(o/1e3))),t=requestAnimationFrame(n)};return n(),{add:t=>{e.push(t)},remove:t=>{e.splice(e.indexOf(t)>>>0,1)},removeListeners(){t&&(cancelAnimationFrame(t),t=null)}}})()),k),E=(e,{onHandler:t,offHandler:n,whileHandler:o,setHandler:r})=>{let s,i,c,p=!0,h=!0;if(t){const e=t;t=()=>{e({firstTrigger:p})}}if(n){const e=n;n=()=>{e({firstTrigger:p})}}if(r){const e=r;r=()=>{e(i,{prevValue:c,firstTrigger:p})}}const f=x((()=>{const d=e();c=i,i=d,c!==i&&(h&&(s="boolean"==typeof i),r&&a(r),s&&(i?(t&&a(t),o&&_().add(o)):(n&&a(n),o&&_().remove(o))),p=h,h=!1)}));return()=>{o&&_().remove(o),t&&d(t),n&&d(n),r&&d(r),f()}},D=(e,t)=>E(e,"function"==typeof t?{setHandler:t}:t),O=(e,t)=>E(e,{onHandler:t});var P={};!function(e){var t=Object.prototype.hasOwnProperty,n="~";function o(){}function r(e,t,n){this.fn=e,this.context=t,this.once=n||!1}function s(e,t,o,s,i){if("function"!=typeof o)throw new TypeError("The listener must be a function");var c=new r(o,s||e,i),a=n?n+t:t;return e._events[a]?e._events[a].fn?e._events[a]=[e._events[a],c]:e._events[a].push(c):(e._events[a]=c,e._eventsCount++),e}function i(e,t){0==--e._eventsCount?e._events=new o:delete e._events[t]}function c(){this._events=new o,this._eventsCount=0}Object.create&&(o.prototype=Object.create(null),(new o).__proto__||(n=!1)),c.prototype.eventNames=function(){var e,o,r=[];if(0===this._eventsCount)return r;for(o in e=this._events)t.call(e,o)&&r.push(n?o.slice(1):o);return Object.getOwnPropertySymbols?r.concat(Object.getOwnPropertySymbols(e)):r},c.prototype.listeners=function(e){var t=n?n+e:e,o=this._events[t];if(!o)return[];if(o.fn)return[o.fn];for(var r=0,s=o.length,i=new Array(s);r<s;r++)i[r]=o[r].fn;return i},c.prototype.listenerCount=function(e){var t=n?n+e:e,o=this._events[t];return o?o.fn?1:o.length:0},c.prototype.emit=function(e,t,o,r,s,i){var c=n?n+e:e;if(!this._events[c])return!1;var a,d,p=this._events[c],h=arguments.length;if(p.fn){switch(p.once&&this.removeListener(e,p.fn,void 0,!0),h){case 1:return p.fn.call(p.context),!0;case 2:return p.fn.call(p.context,t),!0;case 3:return p.fn.call(p.context,t,o),!0;case 4:return p.fn.call(p.context,t,o,r),!0;case 5:return p.fn.call(p.context,t,o,r,s),!0;case 6:return p.fn.call(p.context,t,o,r,s,i),!0}for(d=1,a=new Array(h-1);d<h;d++)a[d-1]=arguments[d];p.fn.apply(p.context,a)}else{var f,l=p.length;for(d=0;d<l;d++)switch(p[d].once&&this.removeListener(e,p[d].fn,void 0,!0),h){case 1:p[d].fn.call(p[d].context);break;case 2:p[d].fn.call(p[d].context,t);break;case 3:p[d].fn.call(p[d].context,t,o);break;case 4:p[d].fn.call(p[d].context,t,o,r);break;default:if(!a)for(f=1,a=new Array(h-1);f<h;f++)a[f-1]=arguments[f];p[d].fn.apply(p[d].context,a)}}return!0},c.prototype.on=function(e,t,n){return s(this,e,t,n,!1)},c.prototype.once=function(e,t,n){return s(this,e,t,n,!0)},c.prototype.removeListener=function(e,t,o,r){var s=n?n+e:e;if(!this._events[s])return this;if(!t)return i(this,s),this;var c=this._events[s];if(c.fn)c.fn!==t||r&&!c.once||o&&c.context!==o||i(this,s);else{for(var a=0,d=[],p=c.length;a<p;a++)(c[a].fn!==t||r&&!c[a].once||o&&c[a].context!==o)&&d.push(c[a]);d.length?this._events[s]=1===d.length?d[0]:d:i(this,s)}return this},c.prototype.removeAllListeners=function(e){var t;return e?(t=n?n+e:e,this._events[t]&&i(this,t)):(this._events=new o,this._eventsCount=0),this},c.prototype.off=c.prototype.removeListener,c.prototype.addListener=c.prototype.on,c.prefixed=n,c.EventEmitter=c,e.exports=c}({get exports(){return P},set exports(e){P=e}});const $=new P,W=[],j=e=>{W.push(e)},S=(e,t)=>{!!W.find((t=>t===e))&&$.emit(e,t)};let F=!0,A=!1;const H=new Proxy({},{get:(e,t)=>e[t],set:(e,t,n)=>(A&&(e[t]=n),!0),deleteProperty:()=>!0}),I=(e,t)=>{"undefined"!=typeof window&&(F&&(window.gozer=H,F=!1),A=!0,H[e]=t,A=!1)};let L=!1;const M=new Map;let T;I("setDevMode",(e=>{L=!!e,M.forEach(((e,t)=>{t(L)}))})),I("isDevMode",(()=>L)),((e,t=!0)=>{M.set(e,e),t&&e(L)})((e=>{T=e}));const B=({cmd:e="log",prefix:t="",backgroundColor:n="black",textColor:o="white",enabled:r=!0}={})=>{let s;const i=(...e)=>{s=!1};return i.force=e=>(s=e,i),i.enable=()=>{!0},i.disable=()=>{!1},i.setEnabled=e=>{!!e},i};let U=0;const z={created:0,destroyed:0,internal:new WeakMap},N=()=>z,q=B({prefix:"[Component]",backgroundColor:"crimson",enabled:!1});B({prefix:"[Component Stats]",backgroundColor:"yellow",textColor:"black",enabled:!0});class R{constructor(){(e=>{const t=`${e.constructor.name}-${U++}`;z.created+=1,q(`Create: ${t}`),z.internal.set(e,{id:t,setupInvoked:!1,destroyInvoked:!1,effectCleanupFunctions:null})})(this),this.onInit&&this.onInit()}async setup(...e){if(z.internal.get(this).setupInvoked)throw new Error(`setup() can only be invoked once for ${this.constructor.name}`);let t,n;if(z.internal.get(this).setupInvoked=!0,"function"==typeof this.props&&(this.props=this.props()),this.onBeforeSetup&&await this.onBeforeSetup(...e),e[0]&&e[0].options){const n=e[0];({options:t}=n)}if(this.options=Object.freeze(Object.assign({},this.options,t)),e[0]&&e[0].props){const t=e[0];({props:n}=t)}n=Object.assign({},this.props,n);const o=Object.keys(n);var r;return 0!==o.length&&(n=v(n),this.props=n),this.onSetup&&await this.onSetup(...e),this.onAfterSetup&&await this.onAfterSetup(...e),this.props&&o.forEach((async e=>{const t=`${e[0].toUpperCase()}${e.substr(1)}`,n=`set${t}`,o=`on${t}`,r=`off${t}`,s=`while${t}`,i=this[n]?this[n].bind(this):void 0,c=this[o]?this[o].bind(this):void 0,a=this[r]?this[r].bind(this):void 0,d=this[s]?this[s].bind(this):void 0;if(!(i||c||a||d))return;let p=z.internal.get(this).effectCleanupFunctions;p||(p=[],z.internal.get(this).effectCleanupFunctions=p),p.push(D((()=>this.props[e]),{setHandler:i,onHandler:c,offHandler:a,whileHandler:d}))})),r=this,W.forEach((e=>{const t="on"+(e[0].toUpperCase()+e.slice(1));r[t]&&(r[t]=r[t].bind(r),$.on(e,r[t]))})),this}destroy(...e){if(z.internal.get(this).destroyInvoked)throw new Error(`destroy() can only be invoked once for ${this.constructor.name}`);var t;z.internal.get(this).destroyInvoked=!0,t=this,W.forEach((e=>{const n="on"+(e[0].toUpperCase()+e.slice(1));t[n]&&$.off(e,t[n])})),this.onBeforeDestroy&&this.onBeforeDestroy(...e),Object.entries(this).forEach((([e,t])=>{t instanceof R&&!z.internal.get(t).destroyInvoked&&(t.destroy(),this[e]=null)}));const n=z.internal.get(this).effectCleanupFunctions;if(n){const e=n.length;for(let t=0;t<e;t+=1)n[t]();z.internal.get(this).effectCleanupFunctions=null}this.onDestroy&&this.onDestroy(...e),this.props&&(w(this.props),this.props=null),this.options&&(this.options=null),this.destroyed=!0,(e=>{const t=`${e.constructor.name}-${U++}`;z.destroyed+=1;const n=z.created-z.destroyed;z.internal.delete(e),q(`Destroy: ${t} ( ${z.created}-${z.destroyed}=${n} )`)})(this)}}export{R as C,P as a,O as b,j as c,w as d,D as e,N as g,b as i,x as o,v as r,S as t};
